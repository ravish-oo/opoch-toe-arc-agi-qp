# WO-2 — Embedding & Period tests (topleft/center embed; byte-exact period detection)

## Anchors to read before coding

* `03_annex.md` A.1–A.3 (byte-exact equality, int64 only, lex rules)
* `04_engg_spec.md` §2 (Embedding) and §7/§8 (Period/projector wording moved to engineering spec)
* `05_contracts.md` (Canonical predicates, Orders, FREE vs PAID, Idempotence)

All behavior here must match those anchors verbatim.

---

## Mature libraries & exact functions (no algorithm invention)

* **NumPy** (only):

  * **Padding** for embedding: `numpy.pad` with `mode='constant', constant_values=-1` for the pad sentinel. ([NumPy][1])
  * **Rolling** for period checks: `numpy.roll(a, shift, axis=0/1)`. ([NumPy][2])
  * **Byte-exact equality**: `numpy.array_equal(a, b)` (no tolerance). ([NumPy][3])
* **(From WO-1)** center predicate uses SciPy’s `scipy.ndimage.center_of_mass` over a boolean “content != 0” mask. You will **call** the predicate implemented in WO-1; do not re-implement it. (Reference: COM doc.) ([SciPy Documentation][4])
* **Hashing for receipts**: Python `hashlib.sha256` over raw C-order bytes (`ndarray.tobytes(order='C')`). (Stdlib reference.) ([Python documentation][5])

No other libs. No RNG. No threads/JIT.

---

## Module to implement: `src/arcsolver/embed.py`

### 1) `embed_to_canvas(Y: np.ndarray, H_out: int, W_out: int, mode: str) -> np.ndarray`

Deterministic, byte-exact embedding per anchors.

* **Inputs**:

  * `Y`: int32 grid (H_in, W_in), values in {−1,0..9}; treat −1 as padding only if already present.
  * `(H_out, W_out)` target canvas.
  * `mode`: `'center'` or `'topleft'`. Source of truth is **WO-1** `center_predicate_all(...)`.

* **Behavior**:

  * If `mode == 'topleft'`: place `Y` at row 0, col 0; pad bottom/right with −1.

    * Implementation: allocate `out = full((H_out, W_out), -1, dtype=int32)`; then `out[:H_in, :W_in] = Y`.
    * Alternatively, `np.pad` with `((0, H_out-H_in), (0, W_out-W_in))`, `mode='constant', constant_values=-1`. ([NumPy][1])
  * If `mode == 'center'`: compute integer offsets

    * `r0 = (H_out - H_in) // 2`, `c0 = (W_out - W_in) // 2` (anchors’ 0.5 rule is already decided by the predicate in WO-1).
    * Fill `out[r0:r0+H_in, c0:c0+W_in] = Y`; pad rest with −1.
  * **No clipping**: if `H_in > H_out` or `W_in > W_out`, raise `UNSAT(EmbeddingSize)`; do **not** crop.

* **Returns**: int32 array (H_out, W_out) with −1 as pad. **Byte-exact**.

### 2) `periods_2d_exact(A: np.ndarray) -> tuple[int, int]`

Byte-exact torus period detection across rows and columns (anchor §7).

* **Inputs**: int32 array (H, W); −1 allowed (treated as just another value in equality test; no special case here).
* **Behavior**:

  * For the y-axis: find minimal `p_y ∈ {1..H}` such that `np.array_equal(A, np.roll(A, shift=p_y, axis=0))` is **True**. If none until H, set `p_y = H`. ([NumPy][2])
  * For the x-axis: minimal `p_x ∈ {1..W}` with `np.array_equal(A, np.roll(A, shift=p_x, axis=1))`; else `p_x = W`.
  * Return `(p_y, p_x)`. This is lex input to §7 projector logic later.
* **Notes**:

  * Strict byte equality (`array_equal`), never `allclose`. ([NumPy][3])
  * Complexity O(H·W·(H+W)) in worst case; tiny for ARC sizes (CPU fine).

### 3) `reembed_round_trip_ok(Y: np.ndarray, H_out: int, W_out: int, mode: str) -> bool`

* Re-embed **twice** and assert `array_equal` on the second pass (Π idempotence at this stage). ([NumPy][3])

---

## Receipts (first-class; what to write at WO-2)

For each task `<tid>`, write `receipts/<tid>/wo02.json`:

```json
{
  "stage": "wo02",
  "embedding": {
    "mode": "center" | "topleft",
    "H_out": H_out, "W_out": W_out,
    "reembed_round_trip_ok": true|false,
    "embedded_hash": "<sha256>"
  },
  "periods": {
    "p_y": py, "p_x": px,
    "eq_check_y": true|false,   // A == roll(A, py, axis=0)
    "eq_check_x": true|false    // A == roll(A, px, axis=1)
  }
}
```

* Hash with our helper over raw bytes; equality checks computed with `np.array_equal`. ([NumPy][3])

---

## Harness changes (generic plumbing stays; add WO-2 metrics)

### `src/arcsolver/harness.py`

* Implement `--upto-wo 2` path:

  1. Load each ARC **dict-based** JSON (glob `*.json` → read → iterate `"train"`, `"test"` keys).
  2. Determine `(H_out, W_out)` via WO-1/size law if present; otherwise, for WO-2 tests only, you may use the **current training output** size as provisional canvas (this is only for receipts—final pipeline will use size law).
  3. Compute:

     * `embedded_i = embed_to_canvas(Y_i, H_out, W_out, mode)` for each training output.
     * `reembed_round_trip_ok` on a representative output (or all; up to you).
     * `py, px = periods_2d_exact(embedded_ref)`.
  4. Write `wo02.json` as above.

* Record **progress metrics** with the generic accumulator you already added:

  * `acc_bool(progress, "embed_idempotent_ok", reembed_round_trip_ok)`
  * `acc_bool(progress, "embed_metamorphic_ok", metamorphic_ok)` where:

    * **Metamorphic check:** if a FREE roll/permutation leaves the *predicate* unchanged, it must not change the *chosen mode*. Concretely: apply a **verified FREE** permutation/roll U to all trainings, recompute the centering predicate (WO-1) and confirm the boolean result is identical. (Do **not** compare arrays here; just the predicate result is invariant by spec.)

### `scripts/run_harness.sh`

* Allow `--upto-wo 2`; run it by default when you’re at WO-2.

---

## Reviewer instructions (what to run and report)

1. Run on all 1000 tasks:

   ```bash
   bash scripts/run_harness.sh --upto-wo 2 --strict
   ```
2. Confirm **receipts** exist: `receipts/<task>/wo02.json`.
3. Open `progress/progress_wo02.json` and report:

   * `embed_idempotent_ok` = 100% (byte-equal re-embed round-trip).
   * `embed_metamorphic_ok` = 100% (centering predicate invariant under FREE roll/permutation).
4. Spot-check a few tasks:

   * `periods.eq_check_y/x` are **true** at the returned `(p_y, p_x)`.
   * `embedded_hash` is **identical** across two runs (determinism).
5. Any red metric is an **implementation gap** in WO-2 (not a dataset UNSAT). Fix and rerun.

---

## Anti-optimization guard (CPU)

* No threading/JIT; all operations are O(HW) or O(HW(H+W)) worst-case — trivial at ARC sizes.
* No “smart” approximations (no FFT, no tolerances). Use `array_equal` only. ([NumPy][3])

---

## Adapters & “hard improvements” enforced here

* **Determinism**: byte-exact equality, fixed padding value (−1), stable raster order.
* **Π/idempotence**: re-embed twice and assert byte equality.
* **FREE invariance**: metamorphic predicate check for centering mode.
* **Receipts**: per-task `wo02.json` plus run-level progress aggregation.

---

## Deliverables checklist (implementer)

* [ ] `embed_to_canvas(...)` with exact padding rules using `np.pad` or explicit slice fill. ([NumPy][1])
* [ ] `periods_2d_exact(...)` using `np.roll` + `np.array_equal`. ([NumPy][2])
* [ ] `reembed_round_trip_ok(...)` Π-check.
* [ ] Harness `--upto-wo 2` path; calls `acc_bool` for `embed_idempotent_ok`, `embed_metamorphic_ok`.
* [ ] Receipts written as specified; hashes via `hashlib.sha256` over C-order bytes. ([Python documentation][5])

## Acceptance checklist (reviewer)

* [ ] Metrics: `embed_idempotent_ok=100%`, `embed_metamorphic_ok=100%`.
* [ ] Period `eq_check_y/x == true` at `(p_y,p_x)` for spot-checks.
* [ ] Re-running harness yields identical `embedded_hash` values.
* [ ] Any failure is marked **implementation gap** and fixed before WO-3.

---

### Why these are the right tests now

* **Embedding** is a Π-operation; re-embedding must be idempotent and byte-stable.
* **Period** is a FREE structural property; verifying `A == roll(A, p)` is the exact, library-supported check. ([NumPy][2])
* **Metamorphic** invariance checks confirm we implemented the calculus (FREE vs PAID) correctly without needing final labels. (This is standard for oracle-free testing.)

[1]: https://numpy.org/devdocs/reference/generated/numpy.pad.html?utm_source=chatgpt.com "numpy.pad — NumPy v2.4.dev0 Manual"
[2]: https://numpy.org/devdocs/reference/generated/numpy.roll.html?utm_source=chatgpt.com "numpy.roll — NumPy v2.4.dev0 Manual"
[3]: https://numpy.org/doc/2.1/reference/generated/numpy.array_equal.html?utm_source=chatgpt.com "numpy.array_equal — NumPy v2.1 Manual"
[4]: https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html?utm_source=chatgpt.com "center_of_mass — SciPy v1.16.2 Manual"
[5]: https://docs.python.org/3/library/hashlib.html?utm_source=chatgpt.com "hashlib — Secure hashes and message digests"
