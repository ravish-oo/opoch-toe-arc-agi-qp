# WO-7 — Unified Flow (OR-Tools) — **Updated**

**Goal.** Solve the paid step as a single integer min-cost flow using **OR-Tools SimpleMinCostFlow**, consuming **cached artifacts** from WO-4/5/6 (arrays, not receipts): (A) (mask), integer **costs**, **bin quotas**, **cell caps**, optional **faces** and **equalizer verdicts**. Verify **primal feasibility**, **cost equality** (and **reduced-cost optimality** if API exposes potentials), plus **idempotence**.
**Anchors:** 00 §8; 01 §1/§5–§7/§10–§13; 02 §B/§G; 03 Annex A.1–A.3.

---

## 0) Libraries (no algorithm invention)

* **OR-Tools**: `ortools.graph.pywrapgraph.SimpleMinCostFlow` (`AddArcWithCapacityAndUnitCost`, `SetNodeSupply`, `Solve`, `Flow`, `UnitCost`, `OptimalCost`, `Status`)
* **NumPy**: reshapes, integer checks, `array_equal` (byte-exact), simple reductions

No other solvers, no custom MCF.

---

## 1) Inputs (from cache, not receipts)

Load NPZ artifacts from prior stages (compute on cache miss):

* **WO-4 cache**:
  `A_mask:(N,C) bool`, `bin_ids:(N,) int64`, `H_out,int; W_out,int`
* **WO-5 cache**:

  * `cell_caps:(H,W) int32` → `n[r,j]`
  * (optional) `faces_R:(H,C) int64`, `faces_S:(W,C) int64`
  * (optional) canonical `equalizer_edges` (for receipts only; rows do not need explicit gadgets here)
* **WO-6 cache**:
  `costs:(N,C) int64` (already `to_int_costs`; Π-safe; FREE-projected if needed)

**Feasibility pre-checks (byte-exact integers):**

* All quotas (q[s,c]\ge0); if faces present, (\sum_s q[s,c]=\sum_r R[r,c]=\sum_j S[j,c]) per color. Else throw **IIS@faces** (01 §10–§11).
* For any “constant-on-bin” ((s,c)), enforce `q[s,c] ∈ {0, |allowed(B_s,c)|}`; else **IIS@faces/quotas** tier.

---

## 2) Graph model (single-commodity, shared cell caps)

**Nodes (shared where indicated):**

* `U[s,c]` — bin source per color; **supply = q[s,c]**
* `P[p]` — **shared pixel** per index (p∈[0..N-1])
* `C[r,j]` — **shared cell** per grid cell
* `T` — sink; **demand = −∑_{s,c} q[s,c]**

**Arcs (no faces):**

1. `U[s,c] → P[p]` if (p ∈ B_s) and (A[p,c]=1), `cap=1`, `unit_cost = costs[p,c]`
2. `P[p] → C[r,j]`, `cap=1`, `cost=0` (enforces **one-of-10** per pixel)
3. `C[r,j] → T`, `cap = n[r,j]`, `cost=0` (**shared cell cap**)

**Faces (optional; enforce *one family hard*):**

* **Row faces hard** (`R[r,c]`): **split supplies** upstream (avoid commodity mixing):
  replace `U[s,c]` with `U[s,r,c]` whose supplies sum to `R[r,c]` and wire only to pixels in **row r**; rest of the path unchanged. If a row-split feasible assignment (bins→rows) can’t be achieved (e.g., insufficient eligible pixels), emit **IIS@faces**. Columns are **checked** post-solve (report in receipts).
* **Column faces hard** (mirror): row faces become a post-solve check.

> Rationale: SimpleMinCostFlow is **single-commodity**; shared cell nodes + per-color row sinks loses commodity identity. Splitting supplies enforces per-row (or per-col) totals within a single-commodity graph while retaining shared caps.

---

## 3) Solve & check

**Solve**: `Solve() == OPTIMAL`. Extract flows with `Flow(arc)`.

**Mandatory checks (Annex A.1–A.3):**

* **Primal balance**: node conservation with given supplies/demands (all integer)
* **Capacity**: `0 ≤ Flow ≤ Capacity` on every arc
* **Mask**: any used cost arc must have `A[p,c]=True`
* **One-of-10**: per pixel (p), `∑_c Flow(P[p]→C[r,j],c) ≤ 1` (cap=1 arc guarantees)
* **Cell caps**: per cell `(r,j)`, `∑_c ∑_{p in cell} Flow(P→C) ≤ n[r,j]`
* **Faces**: if hard, verify exact totals; if soft (checked), report post-solve equality

**Cost equality / KKT surrogate:**
`OptimalCost == Σ(Flow*UnitCost)` (integer). If OR-Tools exposes potentials, verify reduced costs ≥ 0.

**Idempotence**: rebuild identical graph; re-solve; byte-compare per-arc flows + `OptimalCost`.

**UNSAT**: on any hard violation, emit IIS at the correct tier per 01 §10–§11.

---

## 4) Stage implementation

**File:** `src/arcsolver/stages_wo07.py`

* **Inputs**: use `cache.load("wo04", task_id)`, `cache.load("wo05", task_id)`, `cache.load("wo06", task_id)`; compute upstream if cache miss; never read receipts for arrays.
* **Build graph**: deterministic node/arc ordering (raster for pixels/cells; lex for bins/colors).
* **Solve**; run checks above; write **WO-7 receipt** (see §5); **save flow** (optional NPZ: `x_pc` sparse encoding).

Register:

```python
from .pipeline import STAGES
STAGES[7] = run_wo07
```

---

## 5) Receipts (first-class, small)

`receipts/<task>/wo07.json`:

```json
{
  "stage": "wo07",
  "graph": {
    "H": 12, "W": 12, "C": 10, "N": 144,
    "nodes_total":  ..., "arcs_total": ...,
    "faces_mode": "none|rows_as_supply|cols_as_supply",
    "faces_consistency_ok": true
  },
  "solve": {
    "status": "OPTIMAL",
    "optimal_cost": 45678,
    "recomputed_cost_ok": true,
    "primal_balance_ok": true,
    "capacity_ok": true,
    "mask_ok": true,
    "one_of_10_ok": true,
    "cell_caps_ok": true,
    "faces_ok": true,
    "kkt_reduced_cost_ok": null,   // or true if potentials available
    "idempotence_ok": true
  }
}
```

(Keep arrays in cache, not in receipts.)

---

## 6) Harness integration

* **Pipeline** already runs `STAGES[1..upto]`; for WO-7 add:

  * cache priming: `--upto-wo 5` once (overnight) to populate `.cache/wo05/` for all tasks
  * shard support: `--tasks shard://wo7_fast` to iterate on 10–50 representative tasks
  * full run: `--tasks all` to gate merges

* **Progress**: aggregate over accepted instances:

  * `flow_feasible_ok`, `one_of_10_ok`, `cost_equal_ok`, `primal_ok`, `faces_ok`, `idempotence_ok`, and `kkt_ok` (if available)

---

## 7) Reviewer – ultra-short acceptance (paste into WO)

Run:

```bash
bash scripts/run_harness.sh --upto-wo 7 --strict --progress
```

**Must be 100%** (over accepted instances):

* `flow_feasible_ok` (OPTIMAL + primal balance + capacities)
* `one_of_10_ok` (pixel cap respected)
* `cost_equal_ok` (Σ flow×cost == solver OptimalCost; integer)
* `kkt_ok` (if potentials) **or** accept `cost_equal_ok & primal_ok` as surrogate
* `faces_ok` (when faces are hard)
* `idempotence_ok` (rebuild+solve → identical flows & cost)
* `budget_preservation_ok` — must be 100% on accepted instances (proves no silent supply clipping).

If anything <100%: it’s a **WO-7 implementation gap** (graph wiring, supplies/demands, capacity, faces modeling, or cost scaling) — attach the `wo07.json` and the NPZ cache hashes for that task.

---

## 8) Dev/CI discipline

* **Receipts** stay small (hashes/stats only).
* **Caches** carry arrays (`.cache/woNN/*.npz`), keyed by `(input_hash, code_hash, free_maps_hash)`; never commit caches.
* For speed: use shard during coding, full suite before merge; caches make full runs fast.

---

