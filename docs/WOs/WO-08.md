# WO-8 — Decode + Bit-meter

**Goal.** Produce the final prediction grid (Y^\hat{}) from WO-7 flows and compute the **bit-meter** (total minted bits) caused by **multiway ties**, per the ledger in 00/02. Tests must prove that multiway ties of size (m) mint exactly (\lceil \log_2 m\rceil) bits.

**Anchors to read before coding:**

* ` @docs/anchors/03_annex.md ` A.1–A.3 (byte-exact integer equality; no epsilons in feasibility)
* ` @docs/anchors/02_addendum.md ` §F (Bit-meter: orbit-size bits `ceil(log2 |orbit|)`)
* ` @docs/anchors/04_engg_spec.md ` §9 (Decode, one-of-10; Option A preferred; Option B if only cell totals available)

Everything below is deterministic and byte-exact; no floats in feasibility or equality.

---

## 0) Libraries (mature, documented; no algorithm invention)

* **NumPy**: `np.argmax`, `np.equal`, `np.array_equal`, integer arithmetic, reshapes/slices.
* **math**: `math.log2`, `math.ceil` for bit-meter.
* **(Optional)** SciPy sparse **only** if you stored `x[p,c]` as sparse; else not needed.

No other libs.

---

## 1) Inputs (from cache; never from receipts)

From `.cache` (compute on cache miss using the pipeline, not receipts):

* **WO-7**:

  * **Preferred**: pixel decisions `x_pc:(N,C) uint8` where `x[p,c] ∈ {0,1}` and (\sum_c x[p,c] ≤ 1).
  * **If you didn’t store `x_pc`**: per-cell per-color totals `f[r,j,c]` and integer **costs**; see §3-B for Option B decode.

* **WO-6**: integer **costs** `costs:(N,C) int64 = round(-ŝ*SCALE)` (Π-safe + FREE-projected).

* **WO-4**: **A_mask:(N,C) bool** (to double-check we never decode disallowed channels).

* **WO-1/2**: `H_out:int, W_out:int` (canvas), `N = H_out * W_out`.

All **arrays** must come from cache; receipts only carry hashes/stats.

---

## 2) Outputs

* `Y_hat:(H_out,W_out) int32` — final grid.
* Bit-meter totals:

  * `bits_at_p:(N,) uint8` — per-pixel bits minted (optional but recommended),
  * `bit_meter_total:int64` — sum of `bits_at_p`.
* Receipt `wo08.json` with the fields in §5.

---

## 3) Decode (two deterministic options)

### 3-A) **Option A (preferred)** — pixel decisions are available (`x_pc`)

This path is O(NC) and 50–100 LOC.

```python
def decode_from_xpc(x_pc: np.ndarray, H:int, W:int) -> np.ndarray:
    """
    x_pc: (N,C) uint8/boolean with one-of-10 guaranteed by WO-7 graph
    returns Y_hat: (H,W) int32
    """
    # one-of-10 check (accept ==1; allow ==0 if pixel unused)
    sel_per_pixel = x_pc.sum(axis=1)
    # deterministically break 0/1: if 0, you can leave background=0 by spec (or report as unassigned)
    chosen = np.argmax(x_pc, axis=1).astype(np.int32)     # argmax picks first (palette lex), consistent
    Y_hat = chosen.reshape(H, W)
    return Y_hat
```

**Sanity checks (byte-exact integers):**

* `np.array_equal(x_pc[p], 0)` ⇒ `Y[p]=0` is acceptable (background); else `x_pc[p,c*]==1` at the chosen color.
* `np.array_equal(x_pc, x_pc.astype(bool))` — guard against non-binary writes.

### 3-B) **Option B (fallback)** — only cell totals `f[r,j,c]` are stored

Deterministic “top-k per cell” decode from §9 of 04_engg_spec. For each cell `(r,j)` and color `c`, choose `k = f[r,j,c]` pixels among those in cell with **lowest integer cost** (highest `ŝ`) and `A_mask[p,c]==True`. Break ties lex by pixel index. Repeat for all colors and cells; enforce one-of-10 by marking chosen pixels and skipping them in subsequent picks.

This is O(N log N) worst-case per cell (tiny N); still ≤100 LOC.

---

## 4) Bit-meter (Π-safe, integer)

**Anchor:** `02_addendum.md §F`: per pixel, minted bits = `ceil(log2 |orbit|)` where “orbit” are **indistinguishable choices**. For WO-8 we use **multiway equal-cost ties** to define “indistinguishable” under the enforced constraints.

For each pixel p:

* Compute `C_p = { c : A_mask[p,c] == True }`.
* Compute `best = min_c costs[p,c]` over `C_p`.
* Define `T_p = { c ∈ C_p : costs[p,c] == best }`.   *(Integer costs per Annex A.2; byte-exact equality is safe.)*
* Bits at p = `math.ceil(math.log2(len(T_p)))` if `len(T_p) ≥ 2`, else `0`.

Sum to get `bit_meter_total`.

```python
def bitmeter_from_costs(costs: np.ndarray, A: np.ndarray) -> tuple[np.ndarray, int]:
    N, C = costs.shape
    big = np.iinfo(costs.dtype).max
    # mask disallowed channels by setting huge cost
    masked_costs = np.where(A, costs, big)
    # best per pixel
    best = masked_costs.min(axis=1)
    # tie counts
    ties = (masked_costs == best[:, None]).sum(axis=1)
    # bits = ceil(log2 m)
    import math
    bits = np.fromiter((0 if m <= 1 else math.ceil(math.log2(int(m))) for m in ties), count=N, dtype=np.int64)
    return bits, int(bits.sum())
```

**Note:** if you want to also factor in **verified palette symmetries** (WO-6), you can restrict `T_p` to a single representative per symmetry orbit; not required by the anchors, optional.

---

## 5) Receipts (first-class)

Write `receipts/<task_id>/wo08.json`:

```json
{
  "stage": "wo08",
  "decode": {
    "mode": "xpc" | "cell_topk",
    "one_of_10_decode_ok": true,
    "mask_ok": true
  },
  "bit_meter": {
    "total_bits": 123,
    "tie_histogram": { "1": 128, "2": 16, "3": 4 },   // counts of |T_p| values (optional)
    "sample_ties": [ {"p": 42, "m": 3}, {"p": 451, "m": 2} ]  // optional
  }
}
```

**What we check**:

* Decode used allowed arcs only (`mask_ok`),
* One-of-10 respected (`one_of_10_decode_ok`),
* Bit-meter totals and a tie histogram (optional) for quick triage.

---

## 6) Stage runner & harness (no “god function”)

**File:** `src/arcsolver/stages_wo08.py`

```python
def run_wo08(ctx: PipelineContext) -> PipelineContext:
    # Load caches: wo07 (x_pc or f[r,j,c]), wo06 (costs), wo04 (A_mask), wo02 (H,W)
    # Decode: prefer x_pc → Y_hat; else cell_topk using costs & A
    # Bit-meter: from integer costs & A (multiway ties)
    # Receipts: write wo08.json with decode+bit_meter fields
    # Cache: save Y_hat.npy and optional bits.npy
    ctx.decode = {"Y_hat_shape": (H,W), "bit_meter_total": int(total_bits), "bits_hash": sha256(bits.tobytes())}
    return ctx

from .pipeline import STAGES
STAGES[8] = run_wo08
```

**Harness:** add `--upto-wo 8` and a progress aggregation:

* `decode_one_of_10_ok` (100%),
* `decode_mask_ok` (100%),
* `bit_meter_check_ok` — synthetic tie tests pass (100%),
* `idempotence_ok` — re-run yields identical `Y_hat` and `bit_meter_total` (100%).

---

## 7) Reviewer instructions (short)

Run:

```bash
bash scripts/run_harness.sh --upto-wo 8 --strict --progress
```

**Must be 100% (over accepted instances):**

* `decode_one_of_10_ok` — each pixel has ≤ 1 selected color in the decoded map.
* `decode_mask_ok` — decoded colors always respect `A_mask`.
* `bit_meter_check_ok` — on synthetic tie cases, `m ∈ {1,2,3,4}` yields per-pixel bits = `ceil(log2 m)` and aggregate sum matches ground truth.
* `idempotence_ok` — re-run WO-8 yields identical `Y_hat` and `bit_meter_total`.

If anything <100%: **WO-8 implementation gap** (mis-decoding from x_pc/f, wrong mask gating, incorrect tie arithmetic, or non-idempotent logic). Attach `wo08.json` and the `.cache/wo07/*.npz` and `.cache/wo06/*.npz` hashes for failing tasks.

---

## 8) Anti-optimization note (CPU)

WO-8 is O(NC) and tiny; don’t introduce threads/JIT; don’t keep floats in any check; everything is integers and byte-exact.

---
