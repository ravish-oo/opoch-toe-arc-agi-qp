# WO-1 — Bins & predicates (periphery–parity bins, bbox on `!=0`, center predicate)

## Read these anchors before coding

* ` @docs/anchors/03_annex.md ` A.1–A.3 (byte-exact equality, int64, lex rules)
* ` @docs/anchors/04_engg_spec.md ` §1, §4 (content = `!=0`, 4-connectivity), and §0 “Global types & helpers”
* ` @docs/anchors/05_contracts.md ` (“Canonical predicates”, “Masks & Equalizers”, global orders)

Everything below must match those anchors verbatim.

---

## Mature libraries & exact functions to use (no algorithm invention)

* **NumPy** for all pixel math and masks:

  * Index selection & mask indices with `np.where` (when used with 1 arg it is equivalent to `.nonzero()`; we use it only for index extraction). ([numpy.org][1])
  * Histograms / counts with `np.bincount` for integer labels (row/col parity, bin IDs), guarantees int output. ([numpy.org][2])
  * Optional histograms with `np.histogram`/`np.histogramdd` if you prefer explicit bin edges; not required but allowed. ([numpy.org][3])
* **SciPy ndimage** for centroid (center predicate):

  * `scipy.ndimage.center_of_mass` on a boolean “content” mask (values `!=0`). It computes sub-pixel centroids robustly; we will round only for the predicate threshold. ([SciPy Documentation][4])
* **(Optional alternative)** `skimage.measure.regionprops` if you want bbox/centroid from labeled content; allowed but not required in WO-1. Use *only* to read bbox/centroid; do not label here (labeling comes in later WOs). ([Scikit-Image][5])

We are **not** using any other libs here.

---

## Module to implement

### `src/arcsolver/bins.py`

#### 1) `build_bins(H: int, W: int) -> tuple[np.ndarray, list[np.ndarray]]`

Create disjoint **periphery–parity bins** exactly as in the anchors:

* **Periphery flags**: top row, bottom row, left col, right col, and *interior* (everything else).
* **Parity flags**: `r % 2`, `c % 2`.
* **Bins** are intersections of (periphery flag) × (parity pair), **drop empties**.
* **Return**:

  * `bin_ids`: `np.ndarray[int64]` of shape `(H*W,)` (raster-flattened), giving the **bin index** for each pixel.
  * `bins`: `list[np.ndarray[int64]]`, where each entry is the 1-D array of flattened pixel indices belonging to that bin, **sorted in raster order**.

**Implementation details (must do):**

* Make index grids via `np.arange` and integer arithmetic; use `np.where` or boolean masks to collect indices. ([numpy.org][1])
* Compute parity with integer `% 2`; compute periphery masks with equality/inequality on `r`, `c`.
* Build `bin_ids` with an `np.full(H*W, fill_value=-1, dtype=np.int64)`, then fill per bin.
* Use `np.bincount` in tests/receipts to summarize counts per bin deterministically. ([numpy.org][2])

#### 2) `bbox_content(grid: np.ndarray) -> tuple[int,int,int,int] | None`

* **Content definition**: values `!= 0` (background is 0; `-1` padding is **treated as 0** per anchors).
* Find **byte-exact** min/max row/col of content pixels.
* If no content, return `None`.
* Implementation: `rows, cols = np.where(mask)`; bbox = `(rows.min(), rows.max()+1, cols.min(), cols.max()+1)` in **Python slice convention** (end-exclusive). ([numpy.org][1])

#### 3) `center_predicate_all(train_outputs_emb: list[np.ndarray], H_out: int, W_out: int) -> bool`

* For **every** training output (already embedded), compute centroid of the content mask (`!=0`) using **SciPy** `ndimage.center_of_mass`. ([SciPy Documentation][4])
* Treat `-1` as 0 before calling COM.
* The **canvas center** is `((H_out-1)/2, (W_out-1)/2)` (row, col).
* Predicate is **true** iff for each training `i`, both `|row_com_i - (H_out-1)/2| ≤ 0.5` and `|col_com_i - (W_out-1)/2| ≤ 0.5` (anchors).
* Return `True` → `'center'` embedding; else `False` → `'topleft'`.

> Note: if you prefer `skimage.measure.regionprops`, that’s also acceptable to compute centroid from a labeled mask, but SciPy COM is simpler here. ([Scikit-Image][6])

---

## Dtypes, equality, and orders (re-stated)

* All arrays: `int32` for grids, `int64` for indices/counts, **byte-exact** comparisons (no eps). Anchors 03.A.1–A.3.
* **Raster order** for pixels (row, then col).
* Bin IDs and bin index lists must be **sorted in raster order** (needed for determinism and later flows).

---

## Receipts (first-class, what to write at WO-1)

For each task `<tid>`, append `receipts/<tid>/wo01.json`:

```json
{
  "stage": "wo01",
  "canvas": {"H_out": ..., "W_out": ...},   // if known, else null
  "bins": {
    "num_bins": B,
    "bin_counts": [c0, c1, ...],            // via np.bincount over bin_ids
    "bin_ids_hash": "<sha256>",             // hash of int64 bin_ids (flattened raster order)
    "bin_index_hashes": ["<sha256>", ...]   // per-bin list hashes (each int64 array)
  },
  "bbox": {
    "has_content": true|false,
    "bbox_slices": [r0,r1,c0,c1] || null
  },
  "center_predicate": {
    "mode": "center" | "topleft",
    "per_train_distances": [[dr, dc], ...]  // absolute deltas to canvas center for each training
  }
}
```

* Use our `hash_utils.hash_ndarray_int` for hashes.
* This receipt lets the reviewer verify **Π-safety** (byte-exact content, fixed bins), and the predicate logic exactly matches anchors.

---

## Harness changes (stage-aware)

### `src/arcsolver/harness.py`

* Add `--upto-wo 1` behavior:

  1. Load ARC tasks (**dict-based JSON**): glob `*.json`, open, then iterate **dict keys** to get `train` and `test` entries. *(This matches your PS—real ARC is dict-based.)*
  2. For each training output grid **already embedded** (if §2 isn’t implemented yet, call a local “assume topleft” embed stub that is byte-no-op for matching canvases), compute:

     * bins for **the inferred or current canvas** (if size isn’t inferred yet, use current training’s shape),
     * bbox on each training output,
     * center predicate across trainings (only if the output canvas is known; else set `mode="topleft-pending-size"`).
  3. Write `wo01.json` receipts as above.
  4. Assert deterministic invariants:

     * All bin lists sorted;
     * `sum(bin_counts) == H*W`;
     * bbox is inside `[0,H]×[0,W]` or `None` (no content);
     * If center predicate says `'center'`, every `(dr,dc) ≤ 0.5`.

### `scripts/run_harness.sh`

* Accept a parameter to run up to WO-1:

  ```bash
  python -m src.arcsolver.harness --data-root data/arc --upto-wo 1 --strict
  ```

---

## Reviewer instructions (how to check on all 1000 tasks)

1. **Run WO-1 over full ARC**

   ```bash
   bash scripts/run_harness.sh   # with --upto-wo 1
   ```
2. **Check receipts exist** at `receipts/<task>/wo01.json` for every task.
3. **Verify determinism**:

   * Run twice; **byte-diff** receipts are identical.
   * Spot-check a few tasks:

     * `bin_ids_hash` remains the same if you re-run on another machine with pinned env.
     * `sum(bin_counts) == H*W`.
     * If `center_predicate.mode=="center"`, each `dr,dc ≤ 0.5` exactly.
4. **Identify gaps**:

   * If any receipt shows invalid geometry (e.g., bbox outside canvas, bin counts not summing, hashes changing run-to-run), this is an **implementation gap** in WO-1.
   * If a task has **no content** (all zeros) and `bbox=None`, that is **valid** (not UNSAT). The predicate must return `'topleft'`.
   * There is no notion of “task UNSAT” in WO-1; UNSAT doesn’t apply yet.

This ensures **math ↔ implementation = 1:1** for bins and predicates.

---

## Anti-optimization guard (CPU, no shortcuts)

* Do **not** introduce parallel loops or JIT; NumPy vectorization is sufficient.
* Do **not** use float thresholds anywhere (all equality is byte-exact).
* Runtime here is O(HW) per grid. On CPU this is trivial.

---

## Adapters & “hard improvements” pulled in

* **Determinism contract** from WO-0 (env vars, dtypes, sorted iteration).
* **Π-safe “content”** definition fixed: `!=0` only; `-1` padding treated as 0 (anchors).
* **Stable hashing** for receipts.
* **No algorithm invention**: we rely on NumPy and SciPy standard APIs for mask indices and COM. ([numpy.org][1])

---

## Tiny unit checks (optional but recommended)

* `test_bins.py`: given a small H×W grid, `build_bins`’s `bin_ids_hash` matches a frozen value; `sum(bin_counts) == H*W`.
* `test_bbox.py`: synthetic grids with known content; bbox equals expected slices.
* `test_center_predicate.py`: symmetric toy patterns centered/off-center produce True/False as expected.

These don’t replace running the full ARC suite; they prevent regressions.

---

## Deliverables checklist (implementer)

* [ ] `src/arcsolver/bins.py`: `build_bins`, `bbox_content`, `center_predicate_all` as specified.
* [ ] `src/arcsolver/harness.py`: `--upto-wo 1` path that writes `wo01.json` and asserts invariants.
* [ ] `receipts` populated for all tasks; hashes and counts consistent.
* [ ] No floats in equality; all arrays correct dtypes; sorted orders respected.

## Acceptance checklist (reviewer)

* [ ] Anchors matched exactly (content `!=0`; padding −1 treated as 0; byte-exact ops).
* [ ] Receipts present and byte-stable across two runs.
* [ ] `bin_ids_hash` constant across machines (with pinned env).
* [ ] Bbox/center predicate values pass invariant checks.
* [ ] Any failure is tagged as **implementation gap**, not “task issue,” and fixed before WO-2.

---

[1]: https://numpy.org/devdocs/reference/generated/numpy.where.html?utm_source=chatgpt.com "numpy.where — NumPy v2.4.dev0 Manual"
[2]: https://numpy.org/doc/2.1/reference/generated/numpy.bincount.html?utm_source=chatgpt.com "numpy.bincount — NumPy v2.1 Manual"
[3]: https://numpy.org/devdocs/reference/generated/numpy.histogram.html?utm_source=chatgpt.com "numpy.histogram — NumPy v2.4.dev0 Manual"
[4]: https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html?utm_source=chatgpt.com "center_of_mass — SciPy v1.16.2 Manual"
[5]: https://scikit-image.org/docs/0.25.x/api/skimage.measure.html?utm_source=chatgpt.com "skimage.measure — skimage 0.25.2 documentation"
[6]: https://scikit-image.org/docs/0.25.x/auto_examples/segmentation/plot_regionprops.html?utm_source=chatgpt.com "Measure region properties — skimage 0.25.2 documentation"
