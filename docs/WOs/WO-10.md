Perfect—here’s the **expanded, over-specific WO-10 (End-to-end Φ + receipts)** you can hand to the implementer and reviewer. It glues WOs 1…9, writes the final receipts, and produces a golden evaluation report against a fixed ARC subset, all **grounded in the anchors** and using only mature, documented libraries.

---

# WO-10 — End-to-end Φ + receipts

**Goal.** Orchestrate the full pipeline Φ for each `(task_id, test_input_k)`:

1. use **WO-9A** packs and **WO-9B** outcomes to pick the final pack or IIS,
2. if **feasible** → **WO-8 decode** to produce `Ŷ`, and
3. write **final receipts** and **golden evaluation** (exact-match vs ground truth) on a fixed subset.

**No new algorithms** here: WO-10 is orchestration + receipts + evaluation.

---

## Anchors to read before coding

* ** @docs/anchors/00_math_spec.md **: §8 (budgets, faces optional), §16 (Φ selection order);
* ** @docs/anchors/01_addendum.md **: §10 (laminar greedy relax), §11 (IIS), §12 (packs selection lex-min), §F (bit-meter);
* ** @docs/anchors/03_annex.md **: A.1–A.3 (byte-exact integers, determinism), Theorem 1 (Φ idempotence via TU optimality/fixed-point rows).

Everything below operationalizes these sections 1:1.

---

## Libraries (mature, documented)

* **NumPy**: `np.array_equal`, `np.argmax`, `np.unique(return_counts=True)`, `np.frombuffer`; stable/byte-exact ops only (Annex A.1–A.3).
* **json / hashlib / pathlib / time** (stdlib): canonical JSON (`sort_keys=True, separators=(",",":")`), SHA-256 hashing, path ops, timing.
* **(Already in pipeline)**: OR-Tools is **not** called directly in WO-10; it’s used through WO-7 stage runners invoked by WO-9B.

No new external libs.

---

## Inputs (from cache / prior stages; **never** from receipts)

For each `(task_id, test_id)`:

* **WO-9A cache**: `packs.json` (deterministic list of packs).
* **WO-9B results**: a list of `result_α` for each pack (`feasible` + WO-7 feasibility certificate **or** `iis` for infeasible).
* **WO-8 cache** (if you wrote it): `x_pc:(N,C)` (optional; else WO-10 calls the WO-8 decode function directly).
* **WO-6 cache**: `costs:(N,C)` for bit-meter and logging.
* **WO-4 cache**: `A_mask:(N,C)` for decode checks (mask_ok).
* **WO-2/WO-1 cache**: `H_out, W_out` and size-law info (for grid shape and IDs).
* **ARC ground truth** (for evaluation mode only): the task JSON (dict-based) with `test` → list of `{"input":..., "output":...}`.

---

## Outputs

Per `(task_id, test_id)`:

* **Final**:

  * If feasible: `Y_hat:(H,W) int32`, `Δbits:int`, `selected_pack_id`, cost proof (from WO-7), timing/hash fields.
  * If infeasible: `IIS` object (hard tier only, 1-minimal), `selected_pack_id:null`.
* **Receipts**: `wo10.json` (schema in §5).
* **Evaluation** (if ground truth available): `eval.json` (per test grid exact-match report) and a **corpus summary** report.

---

## Algorithm (exact orchestration)

For each `(task_id, test_id)`:

### Step 1 — Load packs & outcomes

* Read `packs = .cache/wo09/<task>.<test>.packs.json` (from WO-9A).
* For each pack `α` (lex order from 9A), read the corresponding WO-9B result: `result_α`.

### Step 2 — Select the **final pack** (01 §12; 00 §16)

* If **any** `result_α.feasible=True`: **choose lex-min feasible** pack by:

  ```
  comparator = (optimal_cost_α, delta_bits_α, canvas_lex(H,W), pack_id)
  ```

  Where `optimal_cost_α` comes from WO-7 (integer, Annex A.2), `delta_bits_α` from WO-8/WO-6 (sum of bit-meter bits), `canvas_lex` = `(H,W)` ascending (Annex A.3). This is the lex-min “lattice-least” selection per §16.

* Else (**no** feasible packs): choose the pack whose `IIS` is present and minimal (you already computed a 1-minimal IIS in WO-9B). Record `selected_pack_id = null` and `final.status="INFEASIBLE"`.

### Step 3 — If feasible: **Decode** with WO-8

* If `x_pc` exists in WO-7 cache → decode with **Option A** (argmax one-hot) into `Ŷ`, as you did in WO-8.
* Else → call the WO-8 decode function (preferred: maintain a small callable `decode_from_xpc` and `bitmeter_from_costs`).
* **Checks**: `one_of_10_decode_ok`, `decode_mask_ok` (byte-exact), **idempotence** (re-decode; same `Ŷ`).
* Compute **bit-meter** (`ceil(log2 m)` per pixel for equal-cost allowed ties; integer costs from WO-6). Sum to `Δbits`.

### Step 4 — Assemble **final receipt** and **cache output**

* Write `receipts/<task>/<test>/wo10.json` with the fields in §5.
* Persist `Ŷ` into `.cache/wo10/<task>.<test>.y_hat.npy` (int32) and a `meta.json` with hashes & timing.

*(Optional)* If your deployment wants **two predictions per test** (ARC leaderboard allows two per test output): record the **backup** feasible pack’s `Ŷ2` as `backup_prediction` and include its `pack_id_2`, `cost_2`, `Δbits_2` in the receipt. (This is a policy choice; not required by anchors.)

---

## Receipts schema (`wo10.json`)

Per `(task_id, test_id)`:

```json
{
  "stage": "wo10",
  "task_id": "00576224",
  "test_id": 0,
  "selected_pack_id": "size=12x12|faces=none|free=[roll(2,0)]",
  "final": {
    "status": "OPTIMAL",                         // or "INFEASIBLE"
    "y_hat_hash": "<sha256-of-bytes (C-order)>", // only if OPTIMAL
    "delta_bits": 37,                            // sum ceil(log2 m)
    "optimal_cost": 12345,                       // from WO-7
    "one_of_10_decode_ok": true,
    "decode_mask_ok": true,
    "idempotence_ok": true,
    "budget_preservation_ok": true,              // from WO-7
    "primal_balance_ok": true,                   // from WO-7
    "capacity_ok": true,                         // from WO-7
    "cost_equal_ok": true,                       // from WO-7
    "kkt_ok": true                               // from WO-7, if exposed
  },
  "iis": {
    "present": false                              // true only if INFEASIBLE
  },
  "packs": [
    {
      "pack_id": "...",
      "feasible": true|false,
      "drops": [ {"tier":"faces","what":"R"}, {"tier":"quota","bin":3,"color":7,"drop":2} ],
      "oracle": {"runs": 3, "status": "OPTIMAL"},
      "iis": {"present": false}
    }
  ],
  "hash": "<sha256-of-canonical-JSON>"
}
```

* Hash computed with `json.dumps(obj, sort_keys=True, separators=(",",":"))` and then `sha256` (Annex A.1–A.3 determinism).
* **No arrays** stored in receipts (arrays go to cache); receipts carry **hashes, IDs, proofs**.

---

## Golden evaluation (subset & full)

### 1) Per-task evaluation (exact-match)

* Load ARC task JSON; for each `test[k]`, compare `Ŷ[k]` to `ground_truth_output[k]` (byte-exact integer equality).
* Record result per test grid: `match:true|false`; if **two** predictions are enabled, mark `match:true` if **any** of the two matches.

Produce `receipts/<task>/eval.json`:

```json
{
  "task_id": "...",
  "tests": [
    { "k":0, "status":"OPTIMAL", "match": true },
    { "k":1, "status":"INFEASIBLE", "match": false, "reason": "IIS" }
  ],
  "summary": { "total": 2, "matched": 1 }
}
```

### 2) Corpus summary (subset or full)

For a fixed **golden subset** (e.g., 100 known tasks) or the full 1120:

* Count `OPTIMAL & match`, `OPTIMAL & mismatch`, `INFEASIBLE`.
* Output a run-level report `eval_corpus.json`:

```json
{
  "corpus": "ARC-100-golden",
  "totals": {"tasks": 100, "tests": 123},
  "optimal": {"tests": 110, "matched": 95, "mismatched": 15},
  "infeasible": {"tests": 13, "with_iis": 13},
  "pass_rate_tests": 0.772,
  "hash": "<sha256>"
}
```

**Reviewer command:**

```bash
bash scripts/run_harness.sh --upto-wo 10 --strict --evaluate --subset golden.txt
# or over all 1120:
bash scripts/run_harness.sh --upto-wo 10 --strict --evaluate --all
```

---

## Runner & harness integration (no god function)

**Files**

* `src/arcsolver/stages_wo10.py` — **glue stage**:

  * load WO-9A packs and WO-9B results,
  * select final pack (or IIS),
  * call WO-8 decode if feasible,
  * write `wo10.json`, optionally `eval.json` if ground truth present.

**Pipeline**

```python
from .pipeline import STAGES
STAGES[11] = run_wo10
```

**Harness flags**

* `--upto-wo 10` to execute 1..10 end-to-end.
* `--evaluate` to produce evaluation JSONs (requires ARC ground truth available locally).
* `--subset FILE` (task IDs) or `--all`.

**Progress metrics** (must be 100% on accepted instances):

* `receipt_determinism_ok` — re-run 3–5 tasks; `wo10.json["hash"]` unchanged.
* `final_feasible_ok` — for feasible, WO-7 proof flags all `true` (primal/capacity/cost/budget/idempotence).
* `final_iis_ok` — for infeasible, `iis.present==true` and each IIS row has `feasible_when_removed==true` (or, if you suppress the proof list for perf, require a reproducible `iis.hash` and log how to replay).
* `eval_ok` (if `--evaluate`) — sanity check counts sum correctly and matches are byte-exact.

---

## Reviewer – ultra-short acceptance (paste into WO)

Run:

```bash
bash scripts/run_harness.sh --upto-wo 10 --strict --evaluate --subset golden.txt
```

**Must be 100% (over accepted instances):**

* `receipt_determinism_ok` — `wo10.json` hash stable.
* **Feasible finals:** `final_feasible_ok` (all WO-7 proof flags true; decode checks true; idempotence true).
* **Infeasible finals:** `final_iis_ok` (IIS present, 1-minimal proof fields present).
* **Evaluation:** `eval_ok` (per-test exact match arithmetic correct).

If any <100% → **WO-10 implementation gap** (selection/composition/receipt wiring). Attach `wo10.json`, the WO-9A and WO-9B caches for that task, and the ARC ground truth JSON for the failing test.

---

## Anti-optimization note (CPU)

WO-10 does **no solving**. It reads cache artifacts, selects per §16, calls WO-8 decode if needed, and writes receipts/eval. O(NC) and small JSON IO; runs trivially on CPU.

---