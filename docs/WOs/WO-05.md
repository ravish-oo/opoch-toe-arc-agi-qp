# WO-5 — Equalizers & structure rows

**Goal:** build row sets (no solving) for 1) **spanning-tree equalizers** inside Π-bins, 2) **gravity/settle** fixed-point rows ((I!-!G)y=0) on transient states (absorbing walls), and 3) **harmonic fill** (discrete Dirichlet) interior rows (\Delta u=0) with boundary pins. Prove they **commute**, and that the fixed points are **unique** by construction.

## Anchors to read before coding

* ` @docs/anchors/01_addendum.md ` §3 (bin constancy), §5 (commutativity), §6 (gravity), §7 (harmonic fill)
* ` @docs/anchors/02_addendum.md ` §L (unique fixed point for gravity/fill)
* ` @docs/anchors/03_annex.md ` A.1–A.3 (byte-exact, int64), and Theorem 1 (idempotence)
* ` @docs/anchors/04_engg_spec.md ` §4 (equalizers), §6 (structure), receipts (§14)

Everything below must match those anchors verbatim.

---

## Mature libraries & the exact calls to use (no algorithm invention)

* **NumPy** (int arrays only): boolean masks, indexing, broadcasting.

  * Boolean indexing & equality: `numpy.array_equal`, `==`, `np.where`, `np.nonzero`. (Official docs for boolean indexing & broadcasting.)
* **SciPy sparse graph (csgraph)**: build **trees/Laplacians** deterministically from sparse graphs.

  * **Spanning tree** (any tree suffices):

    * `scipy.sparse.csgraph.breadth_first_tree(graph, i_start, directed=False)` **or**
    * `scipy.sparse.csgraph.minimum_spanning_tree(graph)` (Kruskal-based).
  * **Graph Laplacian** (for discrete Dirichlet rows): `scipy.sparse.csgraph.laplacian(...)` (returns (L) in sparse form).
* **SciPy sparse.linalg** (tests only; not runtime): optional `scipy.sparse.linalg.spsolve` to sanity-check small Dirichlet systems in unit tests.
* **Theory references (for receipts & comments)**:

  * **Absorbing Markov chains** & fundamental matrix (N=(I-Q)^{-1}) (uniqueness/absorption).
  * **Dirichlet problem** uniqueness via maximum principle (discrete analogue).

No NetworkX, no RNG, no threads/JIT.

---

## Module: `src/arcsolver/eqs.py`  (row builders only)

### A) Spanning-tree equalizers (per Π-bin & color)

**API**

```python
def build_equalizer_rows(
    bin_ids: np.ndarray,           # (N,), int64, raster order
    num_bins: int,
    A_mask: np.ndarray,            # (N, C_out) bool (from WO-4)
) -> dict[tuple[int,int], list[tuple[int,int]]]:
    """
    For each (bin s, color c) where trainings proved 'constant on bin' (WO-1 receipts),
    return a list of equalities tying y[(p,c)] == y[(q,c)] along edges of a spanning tree
    over allowed pixels {p ∈ B_s : A[p,c]==True}.
    Output format: {(s,c): [(p1,p2), (p2,p3), ...]} (edges in raster-lex order).
    """
```

**Construction (library-backed, deterministic):**

1. For each bin (s) and color (c), collect allowed pixels (S_{s,c}={p\in B_s: A_{p,c}=1}) in **raster** order.
2. Build an unweighted adjacency among (S_{s,c}) (4-neighborhood on the 2D canvas; indices are flattened).
3. Get a **tree** over (S_{s,c}) using either:

   * **BFS tree** (preferred, deterministic root = first raster pixel): `csgraph.breadth_first_tree(adj, i_start=root, directed=False)`.
   * Or **MST** on a unit-weight graph: `csgraph.minimum_spanning_tree(adj)`. (Overkill but fine.)
4. Convert sparse tree to a raster-sorted edge list `[(p1,p2), ...]`.
5. Each edge defines **one linear row**: (y[(p_1,c)] - y[(p_2,c)] = 0). Rows commute because they are block-diagonal (per bin × color) (anchors §5).

> Note: We only emit equalizers where WO-1 proved “constant on bin”; that predicate is Π-safe and invariant.

---

### B) Gravity/settle rows ((I!-!G)y=0) on transient states

**API**

```python
def build_gravity_rows(
    H: int, W: int,
    walls_mask: np.ndarray,    # (N,) bool; walls=absorbing; transient = ~walls
    direction: str = "down"    # standard ARC gravity
) -> list[tuple[int,int,int]]:  # rows as (row_index, col_index, value) or an equivalent
    """
    Build linear equalities (I-G) y = 0 on transient states:
    for each transient pixel p, y[p] = y[p_down] if p_down is transient,
    else y[p] = y[p] (absorbing).
    Returned as a sparse row list in C-order pixel indexing.
    """
```

**Semantics (anchors §6, §L):**

* Create a **transition** (G) that moves one step “down” if inside the transient set, otherwise stays (absorbing at walls).
* On transient indices (T): rows encode ((I!-!G)y=0) → **unique** fixed point because the “down” graph is **acyclic** (nilpotent (G_T)). Absorbing Markov chain intuition: (Q=G_T) is transient; (N=(I-Q)^{-1}) exists.

We only **build rows** now; flows will respect them later via capacities.

---

### C) Harmonic fill rows (discrete Dirichlet)

**API**

```python
def build_harmonic_rows(
    interior_idx: np.ndarray,     # 1-D int64 indices of interior pixels D
    boundary_idx: np.ndarray,     # 1-D int64 indices ∂D with fixed labels/colors
    H: int, W: int
) -> scipy.sparse.csr_array:
    """
    Build the sparse Laplacian L_D (rows for ∆u = 0) on interior nodes (4-neighborhood),
    with separate boundary pins handled elsewhere (mask/fixed rows).
    Returns CSR matrix of size |D| x |D|.
    """
```

**Construction (library-backed):**

* Build an adjacency for the **whole grid** (4-nbr).
* Call `scipy.sparse.csgraph.laplacian(adj, normed=False)` → (L). Slice (L_{DD}) for interior indices to obtain the **Dirichlet** interior block.
* We **do not solve** (L_{DD} u_D = -L_{D∂} u_{∂}) at runtime (rows only). For a unit test, you may call `spsolve` on a toy (D) to verify uniqueness (theory: maximum principle / uniqueness).

---

## Receipts (first-class)

Write `receipts/<task_id>/wo05.json`:

```json
{
  "stage": "wo05",
  "equalizers": {
    "count_bins": B,
    "count_rows": R_eq,
    "by_bin_color": [
      {"bin": s, "color": c, "nodes": |S_sc|, "edges": |S_sc|-1, "tree_hash": "<sha256>"}
    ],
    "commute_ok": true
  },
  "gravity": {
    "transient_nodes": T,
    "rows_built": R_g,
    "acyclic_ok": true
  },
  "harmonic": {
    "regions": M,
    "sum_L_rows": R_h,
    "laplacian_shape_ok": true,
    "uniqueness_proved_by": "theory",  // max principle
    "unit_test_spsolve_ok": true       // optional: on toy region only
  }
}
```

* **Equalizers**: `tree_hash` = SHA-256 of the CSR tree adjacency bytes (C-order) for reproducibility.
* **Commutation**: add rows in two different orders (e.g., sort by `(bin,color)` vs `(color,bin)`) and assert identical model hash; rows commute by block-diagonality (anchors §5).
* **Gravity**: prove `acyclic_ok` by counting edges only to strictly larger row index (or by topological check); that ensures nilpotent (G_T) (absorbing MC).
* **Harmonic**: `laplacian_shape_ok` checks (|D|\times|D|); uniqueness is from maximum principle / Dirichlet problem (recorded in receipts as a note, optional quick `spsolve` on a tiny (D) for a sanity test).

Hashing uses stdlib SHA-256 over raw CSR data; byte-stable across runs.

---

## Harness changes (progress metrics)

**`src/arcsolver/harness.py`** add `--upto-wo 5` path:

* Build equalizer rows (only where WO-1 proved bin-constancy).
* Build gravity rows using a deterministic walls mask (your spec for walls ≡ “non-free cells” in the chosen component; often “bottom boundary” is absorbing).
* Build harmonic rows only when a closed interior region is detected; otherwise zero.
* Record progress:

```python
acc_bool(progress, "commuting_rows_ok", commute_ok)           # equalizers
acc_bool(progress, "gravity_rows_unique_ok", acyclic_ok)      # settle uniqueness
acc_bool(progress, "harmonic_rows_built_ok", laplacian_shape_ok)  # rows consistent
```

No runtime solves; tests remain structural.

---

## Reviewer instructions (exact)

Run over all 1000 tasks:

```bash
bash scripts/run_harness.sh --upto-wo 5 --strict
```

Verify:

* Receipts `wo05.json` present; re-run → **byte-identical**.
* `progress/progress_wo05.json` shows:

  * `commuting_rows_ok = 100%`
  * `gravity_rows_unique_ok = 100%` (acyclic transient graph)
  * `harmonic_rows_built_ok = 100%` (for tasks where interior exists)

Spot-check a few tasks:

* Tree edges count = nodes−1; `tree_hash` stable.
* Gravity rows only reference valid neighbor indices; no cycles “upwards”.
* Harmonic (L_D) shape matches (|D|×|D|); optional toy `spsolve` okay.

**Any red metric = an implementation gap in WO-5** (never “dataset UNSAT”). Fix and rerun.

---

## Anti-optimization guard (CPU)

* All builds are O(N) to O(N log N) with tiny constants; ARC grids are small.
* No multithreading/JIT; byte-exact integers only.

---

## Why this is on-spec (with sources)

* **Equalizers** commute because they are block-diagonal per bin×color; a single **tree** suffices to tie all allowed pixels (any tree: BFS tree or MST via SciPy csgraph).
* **Gravity** fixed point is unique: transient subgraph is acyclic/downward ⇒ (Q) nilpotent ⇒ ((I-Q)) invertible on (T) (absorbing Markov chain fundamentals).
* **Harmonic** rows come from the discrete **graph Laplacian**; Dirichlet interior has a **unique** solution by the maximum principle (we only build rows; optional test solve with `spsolve`).
* All indexing and boolean operations are **NumPy-documented** primitives (no heuristics, no floats).

---

## Deliverables checklist (implementer)

* [ ] `build_equalizer_rows` using **csgraph.breadth_first_tree** or **minimum_spanning_tree**; emit rows only for bins proven constant.
* [ ] `build_gravity_rows` building ((I-G)) on transient nodes; prove `acyclic_ok`.
* [ ] `build_harmonic_rows` via **csgraph.laplacian** slicing (L_{DD}); **no solve** at runtime; optional toy `spsolve` in tests.
* [ ] Receipts `wo05.json` with hashes and OK flags; progress metrics populated.
* [ ] No floats in feasibility; all dtypes int64; byte-exact ops only.

## Acceptance checklist (reviewer)

* [ ] `commuting_rows_ok = 100%`; receipts re-run byte-identical.
* [ ] `gravity_rows_unique_ok = 100%`; transient graph verified acyclic.
* [ ] `harmonic_rows_built_ok = 100%` for tasks with interiors; Laplacian shapes correct.
* [ ] Failures, if any, are **implementation gaps** in WO-5 and must be fixed before WO-6.

---